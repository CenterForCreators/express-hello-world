
<!DOCTYPE html>

<html>
<head>
<!-- Xumm & XRPL SDKs -->
<script src="https://xumm.app/assets/cdn/xumm.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xrpl/3.2.0/xrpl-latest-min.js"></script>
<!-- Initialize XRPL Client -->
<script>
    const client = new xrpl.Client('wss://s1.ripple.com');
  </script>
<!-- BUILD TAG: CFC-OK -->
<meta charset="utf-8"/><meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Center for Creators â€” CFC on XRPL</title>
<meta content="Center for Creators NFT site â€” Faucet + Marketplace powered by CFC on XRPL." name="description"/>
<!-- Render-hosted SDKs (so gateways don't block) -->
<style>
    .divider{height:1px;background:var(--accent);opacity:0.6;margin:10px 0 14px 0;border-radius:999px}


    :root { --bg:#0b1220; --card:#121a2b; --text:#f6f8ff; --muted:#9fb0d1; --accent:#7db8ff; --ok:#1fcf7c; --warn:#ffcc00; --err:#ff6b6b;}
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
    a{color:var(--accent);text-decoration:none}
    .wrap{max-width:1100px;margin:0 auto;padding:22px}
    header{display:flex;justify-content:space-between;align-items:center;gap:16px;margin-bottom:22px}
    .brand{display:flex;align-items:center;gap:12px}
    .brand img{width:44px;height:44px;border-radius:10px;display:block;background:#7c3aed}
    h1{font-size:20px;margin:0;line-height:1.2}
    .btn{background:var(--accent);color:#091224;padding:10px 14px;border-radius:10px;border:0;font-weight:700;cursor:pointer}
    .btn.secondary{background:#cfe3ff;color:#041225}
    .btn.ghost{background:transparent;border:1px solid #2a3a60;color:var(--text)}
    .btn.small{padding:8px 10px;font-size:14px}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px}
    .card{background:var(--card);border:1px solid #202c45;border-radius:16px;padding:18px}
    .muted{color:var(--muted)}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .nft-img{width:100%;height:180px;background:#0e1527;border-radius:12px;object-fit:cover;display:block}
    input[type="email"], input[type="text"]{width:100%;outline:none;padding:10px;border-radius:10px;border:1px solid #2a3a60;background:#0e1527;color:#e8f0ff}
    .kv{display:flex;gap:10px;align-items:center}
    .kv div:first-child{width:140px;color:#9fb0d1}
    footer{margin-top:30px;color:#9fb0d1;font-size:14px}
    .status{margin-top:8px;font-size:14px}
    .status.ok{color:var(--ok)} .status.warn{color:var(--warn)} .status.err{color:var(--err)}
    .toast{position:fixed;right:16px;bottom:16px;background:#132b1f;color:#caffa9;border:1px solid #1b5e2c;border-radius:12px;padding:12px 14px;display:none;z-index:9999}
    .spinner{display:none;width:16px;height:16px;border-radius:50%;border:3px solid #2a3a60;border-top-color:var(--accent);animation:spin 0.9s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    /* ensure buttons clickable even in gateway viewer */
    #connectBtn,#claimBtn{pointer-events:auto;opacity:1}
    .captcha{display:flex;gap:8px;align-items:center}
    .captcha .tag{background:#1a2745;color:#cfe3ff;padding:4px 8px;border-radius:999px;font-size:12px}
    .note{font-size:12px;color:#9fb0d1;margin-top:6px}
  </style>
<script>
    // ------- CONFIG (single block) -------
    window.CONFIG = { USE_CORS_PROXY: true, CORS_PROXY: 'https://cors.isomorphic-git.org/', 
      FAUCET_ENDPOINT: 'https://cfc-faucet.onrender.com/api/faucet',
      faucetAmount: 25,
      currencyCode: 'CFC',
      issuer: 'rsxUkmjnAn8PRDz8RYrPusb9mTDYn5NqG8',
};
  </script>
<script>
    // Helpers
    function $(sel){ return document.querySelector(sel); }
    function show(el){ el.style.display='block'; }
    function hide(el){ el.style.display='none'; }
    function toast(msg){ const t=$('#toast'); t.textContent=msg; show(t); setTimeout(()=>hide(t), 3500); }
  </script>
<!-- CDN SDKs (working everywhere) -->
<script src="https://xumm.app/assets/cdn/xumm.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xrpl/3.2.0/xrpl-latest-min.js"></script>
<style>
  .server-waiting-url{ display:none !important; }
</style>
</head>
<body>
<div class="wrap">
<header>

<button class="btn" id="connectBtn">
<span id="addrBadge" style="margin-left:8px;opacity:0.9"></span>Connect Xaman Wallet</button><div ...="" id="emailInput">
</div></header>
<!-- Injected: row (account + balances) -->
<style>
  .walletbar{display:flex;gap:14px;align-items:center;margin:10px 0;padding:10px 12px;border:1px solid #202c45;border-radius:12px;background:#0f1729}
  .tag{background:#1a2745;color:#cfe3ff;padding:4px 8px;border-radius:999px;font-size:12px}
</style>
<div class="walletbar" id="walletbar" style="display:none">
<span class="tag" id="wb_status">Not connected</span>
<span class="muted">Account:</span><span id="wb_account" style="font-family:monospace"></span>
<span class="muted">XRP:</span><span id="wb_xrp">â€”</span>
<span class="muted">CFC:</span><span id="wb_cfc">â€”</span>
<button class="btn small" id="wb_trust" style="display:none" type="button">Add CFC Trustline</button>
<span id="connectedAddress">Not connected</span></div>
<div class="card" id="faucetCard" style="margin-bottom:16px">
<div class="row" style="justify-content:space-between">
<div>
<div id="dailyFaucetTitle" style="font-weight:700;margin-bottom:6px">Daily CFC Faucet</div>
<div class="muted">Claim <strong id="faucetAmount">25</strong> CFC once every 24 hours.</div>
</div>
<div class="tag" id="faucetStatus">Server: Waiting for URL</div>
</div>
<div class="row" id="cfc-captcha-row" style="margin-top:12px">
<div class="row" style="margin-top:10px">
<div id="cfc-captcha" style="margin:10px 0;display:flex;gap:8px;align-items:center;">
<span class="tag" id="capA">0</span> + <span class="tag" id="capB">0</span> =
      <input id="capAns" inputmode="numeric" maxlength="2" placeholder="?" style="width:70px" type="text"/>
<button class="btn small" onclick="if(window.regenCaptcha)window.regenCaptcha()" type="button">â†»</button>
</div>
<button class="btn" id="claimBtn">Claim CFC</button>

<p class="muted" style="font-size:12px; margin-top:6px;">
  Not yet available on mobile devices.
</p>

<div class="spinner" id="claimSpin" style="display:none"></div>
<div class="status" id="claimStatus"></div>

</div>
<div class="muted" id="claimMsg" style="margin-top:8px"></div>
</div>
<div class="divider"></div>
<!-- Tokenization Header Section -->
<div class="nft-header" style="text-align:center; margin:25px 0;">
<h1 style="font-size:28px; font-weight:800; color:#fff; margin-bottom:8px;">
    Tokenization That Empowers Your Purpose
  </h1>
<p style="color:#9fb0d1; font-size:17px; max-width:650px; margin:0 auto;">
    From personal growth to blockchain strategy, every experience on Center for Creators 
    helps you learn, evolve, and earn CFC rewards.
  </p>
</div>
<div class="row" style="margin-bottom:12px">
<button class="btn" id="navMarket">Marketplace</button>
<button class="btn secondary" id="navPurchases">My Purchases</button>
<button class="btn secondary" id="navRedeem">Redeem</button>
</div>
<section id="view-market">
<div class="grid">
<!-- Service NFT -->
<div class="card">
<img alt="Service NFT image" class="nft-img" src="data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1024' height='576' viewBox='0 0 1024 576'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='%237c3aed'/%3E%3Cstop offset='100%25' stop-color='%2322d3ee'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='1024' height='576' fill='url(%23g)'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-family='Inter,Segoe UI,Arial,sans-serif' font-size='60' font-weight='700' fill='%23fff'%3EService NFT â€” 1:1 Session%3C/text%3E%3C/svg%3E"/>
<h3 style="margin:12px 0 6px">Unlock a 60-minute session with Christie Russ.</h3>
<div class="muted" style="margin-bottom:12px">Learn and Earn. Proof of ownership on XRPL. Transferable prior to redemption.</div>
<div class="row" style="justify-content:space-between">
<div class="price-col">
<div class="muted">Price</div>
<div id="price1rlusd"><strong>500 RLUSD</strong></div>
<div class="muted">Â·</div>
<div id="price1xrp"><strong>219 XRP</strong></div>
</div>
<div class="row">
<button class="btn small" id="buy1rlusd">Pay in RLUSD</button>
<button class="btn small secondary" id="buy1xrp">Pay in XRP</button>
</div>
</div>
</div>
<!-- Blockchain Made Simple NFT -->
<div class="card">
<img alt="Blockchain Made Simple NFT" class="nft-img" src="data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1024' height='576' viewBox='0 0 1024 576'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='%2316a34a'/%3E%3Cstop offset='100%25' stop-color='%2384cc16'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='1024' height='576' fill='url(%23g)'/%3E%3Ctext x='50%25' y='46%25' dominant-baseline='middle' text-anchor='middle' font-family='Inter,Segoe UI,Arial,sans-serif' font-size='60' font-weight='700' fill='%23fff'%3EBlockchain Made Simple NFT%3C/text%3E%3Ctext x='50%25' y='54%25' dominant-baseline='middle' text-anchor='middle' font-family='Inter,Segoe UI,Arial,sans-serif' font-size='56' font-weight='600' fill='%23fff'%3EAmazon %231 Best Seller%3C/text%3E%3C/svg%3E"/>
<h3 style="margin:12px 0 6px">Blockchain Made Simple NFT</h3>
<div class="muted" style="margin-bottom:12px">Read and Earn CFC Tokens. Limited edition NFT Book linked to bonus content.</div>
<div class="row" style="justify-content:space-between">
<div class="price-col">
<div class="muted">Price</div>
<div id="price2rlusd"><strong>35 RLUSD</strong></div>
<div class="muted">Â·</div>
<div id="price2xrp"><strong>35 XRP</strong></div>
</div>
<div class="row">
<button class="btn small" id="buy2rlusd">Pay in RLUSD</button>
<button class="btn small secondary" id="buy2xrp">Pay in XRP</button>
</div>
</div>
</div>
<!-- The Power to Rise NFT -->
<div class="card">
<img alt="The Power to Rise NFT" class="nft-img" src="data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1024' height='576' viewBox='0 0 1024 576'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='%23f59e0b'/%3E%3Cstop offset='100%25' stop-color='%23f97316'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='1024' height='576' fill='url(%23g)'/%3E%3Ctext x='50%25' y='45%25' dominant-baseline='middle' text-anchor='middle' font-family='Inter,Segoe UI,Arial,sans-serif' font-size='60' font-weight='700' fill='%23fff'%3EThe Power to Rise NFT%3C/text%3E%3Ctext x='50%25' y='55%25' dominant-baseline='middle' text-anchor='middle' font-family='Inter,Segoe UI,Arial,sans-serif' font-size='56' font-weight='600' fill='%23fff'%3EAmazon %231 Best Seller%3C/text%3E%3C/svg%3E"/>
<h3 style="margin:12px 0 6px">The Power to Rise NFT</h3>
<div class="muted" style="margin-bottom:12px">Read and Earn CFC Tokens. Limited edition NFT Book linked to bonus content.</div>
<div class="row" style="justify-content:space-between">
<div class="price-col">
<div class="muted">Price</div>
<div id="price3rlusd"><strong>25 RLUSD</strong></div>
<div class="muted">Â·</div>
<div id="price3xrp"><strong>11 XRP</strong></div>
</div>
<div class="row">
<button class="btn small" id="buy3rlusd">Pay in RLUSD</button>
<button class="btn small secondary" id="buy3xrp">Pay in XRP</button>
</div>
</div>
</div>
</div> <!-- âœ… closes the grid -->
</section>
<section id="view-purchases" style="display:none">
<div class="grid" id="purchasesGrid"></div>
</section>
<section id="view-redeem" style="display:none">
</section>
<footer>
<p>Powered by the CFC Token on the XRP Ledger. Secured by Xaman â€¢ App: Center for Creators NFT Market. <a href="https://centerforcreators.com" rel="noreferrer" target="_blank">CenterForCreators.com</a></p>
</footer>
</div>
<script>
      const CONFIG = {
  networkWss: 'wss://xrplcluster.com',
  CFC_ISSUER: 'rsxUkmjnAn8PRDz8RYrPusb9mTDYn5NqG8',
  CFC_CODE: 'CFC',
  RLUSD_ISSUER: 'rMxCKbEDwqr76QuheSUMdEGf4B9xJ8m5De',
  XUMM_API_KEY: 'e130c57f-bd16-4458-bee3-de32826dd900',
  EMAIL_FALLBACK_URL: 'https://centerforcreators.com/contact',
  RECEIVER_XRP: 'rU15yYD3cHmNXGxHJSJGoLUSogxZ17FpKd',
  FAUCET_ENDPOINT: 'https://cfc-faucet.onrender.com/api/faucet',
  FAUCET_DAILY_AMOUNT: '25',
  ITEMS: [
    { id: 'svc1', name: 'Private Strategy Session', priceRLUSD: '500', priceXRP: '219' },
    { id: 'wrk1', name: 'Blockchain Made Simple â€” Special Edition Book', priceRLUSD: '35', priceXRP: '15'  },
    { id: 'book1', name: 'The Power to Rise â€” Special Edition Book', priceRLUSD: '25', priceXRP: '11'}
  ]
};

    const client = new xrpl.Client(CONFIG.networkWss)
    const xumm = new Xumm(CONFIG.XUMM_API_KEY)
    let connectedAccount = null

        function setStatus(text){ $('#status').textContent = text }
    function setAddr(text){ $('#address').textContent = text }
    function showError(msg){ const b=document.getElementById('errorBox'); b.textContent=
msg; b.style.display='block' }
    function hideError(){ const b=document.getElementById('errorBox'); b.style.display='none'; b.textContent='' }

    async function ensureConnected(){ if (!client.isConnected()) await client.connect() }

    async function fetchBalances(account){
      await ensureConnected()
      const info = await client.request({ command: 'account_info', account })
      const xrpBalance = (Number(info.result.account_data.Balance) / 1_000_000).toFixed(2)
      document.getElementById('xrpBalance').textContent = `${xrpBalance} XRP`

      const lines = await client.request({ command: 'account_lines', account })
      const cfcLine = lines.result.lines.find(l => l.account === CONFIG.CFC_ISSUER && l.currency === CONFIG.CFC_CODE)
      const cfcBal = cfcLine ? cfcLine.balance : '0'
      document.getElementById('cfcBalance').textContent = `${cfcBal} CFC`

      const row = document.getElementById('trustlineRow')
      if(row){ row.style.display = cfcLine ? 'none' : 'flex' }
      return { xrpBalance, cfcBal, hasCfc: !!cfcLine }
    }

    async function addCfcTrustline(){
      if(!connectedAccount){ alert('Connect your wallet first.'); return }
      await ensureConnected()
      const tx = {
        TransactionType: 'TrustSet',
        Account: connectedAccount,
        LimitAmount: { currency: CONFIG.CFC_CODE, issuer: CONFIG.CFC_ISSUER, value: '1000000000' }
      }
      const payload = await xumm.payload.createAndSubscribe({ txjson: tx }, () => {})
      if(payload?.created?.next) window.open(payload.created.next.always, '_blank')
      const res = await payload.resolved
      if(res.signed){ setStatus('Trustline added. Refreshing balancesâ€¦'); await fetchBalances(connectedAccount) }
      else{ alert('Trustline request was cancelled.') }
    }
    }

   function strToHex(str) {
  return Array.from(new TextEncoder().encode(str))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('')
    .toUpperCase();
}

async function claimFaucet() {
  const msgEl = document.getElementById('claimMsg') || document.getElementById('claimStatus');
  const spin = document.getElementById('claimSpin');
  try {
    if (typeof checkCaptcha === 'function' && !checkCaptcha()) {
      if (msgEl) msgEl.textContent = 'Please solve the math question.';
      return;
    }
    if (!account) {
      if (msgEl) msgEl.textContent = 'Connect your wallet first (top-right).';
      return;
    }

    if (msgEl) msgEl.textContent = 'Claiming...';
    if (spin) spin.style.display = 'inline-block';

    const ep = (window.CONFIG && (CONFIG.FAUCET_ENDPOINT || CONFIG.FAUCET_URL))
      ? (CONFIG.FAUCET_ENDPOINT || CONFIG.FAUCET_URL)
      : 'https://cfc-faucet.onrender.com/api/faucet';

    const res = await fetch(ep, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ account: account, captcha_ok: true })
    });

    const data = await res.json().catch(() => ({}));

    if (data && data.ok) {
      if (msgEl) msgEl.textContent = 'âœ… Claimed 25 CFC successfully!';
      try { await connectXRPLAndLoadBalances(account); } catch (_) {}
      try { if (typeof regenCaptcha === 'function') regenCaptcha(); } catch (_) {}
      try { if (typeof newCaptcha === 'function') newCaptcha(); } catch (_) {}  // moved here
    } else {
      if (msgEl) {
        const err = (data && (data.error || data.message)) || '';
        if (/invalid account/i.test(err)) msgEl.textContent = '';
       else {
  msgEl.textContent = 'âŒ ' + (err || 'Claim failed');

  if ((err || '').includes('24h')) {
    setTimeout(() => {
      if (msgEl) msgEl.textContent = '';
    }, 5000);
      }
    }
  } catch (e) {
    console.error('claim error', e);
    if (msgEl) msgEl.textContent = 'Server error. Try again.';
  } finally {
    if (spin) spin.style.display = 'none';
  }
}

async function buyWithXRP(item){

      const amountDrops = Math.round(Number(item.priceXRP) * 1_000_000).toString()
      const tx = {
        TransactionType: 'Payment',
        Destination: CONFIG.RECEIVER_XRP,
        Amount: amountDrops,
        Memos: [{ Memo: { MemoType: strToHex('CFC-PURCHASE'), MemoData: strToHex(`${item.id}|XRP|${Date.now()}`) } }]
      }
      const payload = await xumm.payload.createAndSubscribe({ txjson: tx }, () => {})
      if (payload?.created?.next) window.open(payload.created.next.always, '_blank')
      const resolved = await payload.resolved
      alert(resolved.signed ? 'Thanks! We received your order. Weâ€™ll deliver your NFT shortly.' : 'Payment was cancelled.')
    }

    async function buyWithRLUSD(item){
  if (!connectedAccount){ alert('Connect your wallet first.'); return }
  await ensureConnected()

  const lines = await client.request({ command: 'account_lines', account: connectedAccount })
  const rlUsdLine = lines.result.lines.find(l => l.account === CONFIG.RLUSD_ISSUER && l.currency === "RLUSD")
  if (!rlUsdLine){ alert('You need an RLUSD trustline before paying.'); return }

  const bal = parseFloat(rlUsdLine.balance || '0')
  if (bal < parseFloat(item.priceRLUSD)){ alert('Insufficient RLUSD balance.'); return }

  const tx = {
    TransactionType: 'Payment',
    Account: connectedAccount,
    Destination: CONFIG.RECEIVER_XRP,
    Amount: { currency: "RLUSD", issuer: CONFIG.RLUSD_ISSUER, value: item.priceRLUSD },
    Memos: [{ Memo: { MemoType: strToHex('RLUSD-PURCHASE'), MemoData: strToHex(`${item.id}|RLUSD|${Date.now()}`) } }]
  }

  const payload = await xumm.payload.createAndSubscribe({ txjson: tx }, () => {})
  if (payload?.created?.next) window.open(payload.created.next.always, '_blank')
  const resolved = await payload.resolved
  alert(resolved.signed ? 'Thanks! We received your RLUSD payment ðŸŽ‰' : 'Payment cancelled.')
}

    function switchView(which){
      document.getElementById('view-market').style.display = which==='market' ? 'block' : 'none'
      document.getElementById('view-purchases').style.display = which==='purchases' ? 'block' : 'none'
      document.getElementById('view-redeem').style.display = which==='redeem' ? 'block' : 'none'
      document.getElementById('navMarket').classList.toggle('secondary', which!=='market')
      document.getElementById('navPurchases').classList.toggle('secondary', which!=='purchases')
      document.getElementById('navRedeem').classList.toggle('secondary', which!=='redeem')
    }

    document.getElementById('navMarket').addEventListener('click', () => switchView('market'))
    document.getElementById('navPurchases').addEventListener('click', async () => { switchView('purchases'); await loadMyPurchases() })
    document.getElementById('navRedeem').addEventListener('click', () => switchView('redeem'))

    function hexToString(hex){ try{ if (!hex) return ''; const clean = hex.startsWith('0x') ? hex.slice(2) : hex; return decodeURIComponent(clean.replace(/(..)/g,'%$1')) }catch(e){ return '' } }

    async function loadMyPurchases(){
      if (!connectedAccount){ document.getElementById('purchasesGrid').innerHTML = '<div class="muted">Connect your wallet to see purchases.</div>'; return }
      await ensureConnected()
      const resp = await client.request({ command:'account_nfts', account: connectedAccount })
      const items = (resp.result.account_nfts||[]).filter(n => n.Issuer === CONFIG.CFC_ISSUER)
      if (!items.length){ document.getElementById('purchasesGrid').innerHTML = '<div class="muted">No CFC-issued NFTs found in this wallet.</div>'; return }
      const grid = items.map(n => {
        const uri = hexToString(n.URI)
        return `
          <div class="card">
            <div class="nft-img" style="display:flex;align-items:center;justify-content:center;color:#9fb0d1">Owned NFT</div>
            <div class="kv"><div>Token ID</div><div style="word-break:break-all">${n.NFTokenID}</div></div>
            <div class="kv"><div>Issuer</div><div>${n.Issuer}</div></div>
            ${uri ? `<div class="kv"><div>Metadata</div><div><a href="${uri}" target="_blank" rel="noreferrer">Open</a></div></div>` : ''}
            <div class="row" style="margin-top:10px">
              <button class="btn small" onclick="document.getElementById('redeemTokenId').value='${n.NFTokenID}'; switchView('redeem');">Redeem</button>
            </div>
          </div>`
      }).join('')
      document.getElementById('purchasesGrid').innerHTML = grid
    }

    document.getElementById('redeemCheck').addEventListener('click', async () => {
      const id = document.getElementById('redeemTokenId').value.trim()
      if (!id){ document.getElementById('redeemResult').textContent = 'Enter a Token ID.'; return }
      if (!connectedAccount){ document.getElementById('redeemResult').textContent = 'Connect your wallet first.'; return }
      await ensureConnected()
      const resp = await client.request({ command:'account_nfts', account: connectedAccount })
      const owned = (resp.result.account_nfts||[]).some(n => n.NFTokenID === id)
      document.getElementById('redeemResult').textContent = owned ? 'âœ… Ownership verified. You can proceed to redeem this NFT.' : 'âŒ This wallet does not currently hold that Token ID.'
    })

    document.getElementById('emailSubmit').addEventListener('click', () => {
      const email = document.getElementById('emailInput').value.trim()
      const box = document.getElementById('emailMsg')
      if(!/.+@.+\..+/.test(email)){ box.textContent='Please enter a valid email.'; return }
      const u = new URL(CONFIG.EMAIL_FALLBACK_URL); u.searchParams.set('email', email); window.open(u.toString(), '_blank')
      box.textContent='Opening contact pageâ€¦'
    })

   document.getElementById('connectBtn').addEventListener('click', connectXaman)
document.getElementById('buy1rlusd').addEventListener('click', () => buyWithRLUSD(CONFIG.ITEMS[0]))
document.getElementById('buy2rlusd').addEventListener('click', () => buyWithRLUSD(CONFIG.ITEMS[1]))
document.getElementById('buy3rlusd').addEventListener('click', () => buyWithRLUSD(CONFIG.ITEMS[2]))
document.getElementById('buy1xrp').addEventListener('click', () => buyWithXRP(CONFIG.ITEMS[0]))
document.getElementById('buy2xrp').addEventListener('click', () => buyWithXRP(CONFIG.ITEMS[1]))
document.getElementById('buy3xrp').addEventListener('click', () => buyWithXRP(CONFIG.ITEMS[2]))
document.getElementById('claimBtn').addEventListener('click', claimFaucet)

switchView('market')

  </script>
<script>
document.addEventListener('DOMContentLoaded', function(){
  try {
    if (typeof newCaptcha !== 'function') {
      window._a=0;window._b=0;
      window.newCaptcha=function(){
        _a=Math.floor(Math.random()*10);_b=Math.floor(Math.random()*10);
        var A=document.getElementById('numA'),B=document.getElementById('numB');
        if(A)A.textContent=_a;if(B)B.textContent=_b;
        var I=document.getElementById('captchaInput'); if(I) I.value='';
      };
    }
    
    const qb=document.getElementById('claimBtn');
    if (qb && !qb.__bound){
      qb.addEventListener('click', function(){
        if (window.claimFaucet) return window.claimFaucet();
        if (window.claim) return window.claim();
      });
      qb.__bound=true;
    }
    if (document.getElementById('numA') || document.getElementById('captchaInput')) newCaptcha();
  } catch(e){}
});
</script>
<style>
    #cfc-cap-ovl { display: none !important; }
#cfc-cap-ovl{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;z-index:9999}
#cfc-cap-card{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:#121a2b;color:#f6f8ff;
  border:1px solid #202c45;border-radius:14px;padding:16px;min-width:280px;box-shadow:0 10px 30px rgba(0,0,0,.4)}
#cfc-cap-card .row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
#cfc-cap-card input{padding:8px;border-radius:8px;border:1px solid #2a3a60;background:#0e1527;color:#fff;width:90px}
#cfc-cap-actions{margin-top:12px;display:flex;gap:8px;justify-content:flex-end}
#cfc-cap-actions button{background:#7db8ff;color:#001428;border:0;border-radius:10px;padding:8px 12px;cursor:pointer;font-weight:700}
#cfc-cap-err{color:#ffb4b4;margin-top:6px;min-height:18px;font-size:14px}
</style>
<div aria-modal="true" id="cfc-cap-ovl" role="dialog">
<div id="cfc-cap-card">
<div style="font-weight:700;margin-bottom:8px">Quick check</div>
<div class="row">
<div id="cfc-cap-err"></div>
<div id="cfc-cap-actions">
<button id="cfcCancel" type="button">Cancel</button>
<button id="cfcOk" type="button">Confirm</button>
</div>
</div>
</div>
<script>
(function(){
  function rand(){ return Math.floor(Math.random()*10); } // 0..9
  function regen(){ window.__cfcA=rand(); window.__cfcB=rand();
    var A=document.getElementById('cfcA'), B=document.getElementById('cfcB'), I=document.getElementById('cfcAns');
    if(A) A.textContent=__cfcA; if(B) B.textContent=__cfcB; if(I) I.value='';
    var E=document.getElementById('cfc-cap-err'); if(E) E.textContent='';
  }
 window.cfcOpenCaptcha = function(){ return; };
  function hide(){ var o=document.getElementById('cfc-cap-ovl'); if(o) o.style.display='none'; }

  document.addEventListener('DOMContentLoaded', function(){
    var ok=document.getElementById('cfcOk');
    var cancel=document.getElementById('cfcCancel');
    if(ok){
      ok.addEventListener('click', function(){
        var I=document.getElementById('cfcAns'); var E=document.getElementById('cfc-cap-err');
        var val=parseInt((I&&I.value)||'',10);
        if(isNaN(val) || val !== (__cfcA+__cfcB)){ if(E) E.textContent='Wrong answer â€” try again.'; regen(); return; }
        window.__cfcCaptchaPassed = true;
        hide();
        try{ if (window.claimFaucet) return window.claimFaucet(); if (window.claim) return window.claim(); }catch(e){}
      });
    }
    if(cancel){ cancel.addEventListener('click', hide); }
  });
})();
</script>
<script>
// Simple math CAPTCHA: digits 0â€“9, refresh each time
let _a = 0, _b = 0;
function newCaptcha(){
  _a = Math.floor(Math.random()*10);
  _b = Math.floor(Math.random()*10);
  const A = document.getElementById('numA'), B = document.getElementById('numB');<script>
window.CFC = window.CFC || {};


</script>

  if (A) A.textContent = _a;
  if (B) B.textContent = _b;
  const I = document.getElementById('captchaInput');
  if (I) I.value = '';
}
function checkCaptcha(){
  const I = document.getElementById('captchaInput');
  if (!I) return true; // if no UI, skip
  const val = parseInt(I.value,10);
  return !isNaN(val) &amp;&amp; (val === (_a + _b));
}
// Initialize captcha when faucet view is shown
(function(){
  // If faucet is the default hidden view, call on DOM ready and when tab switches
  document.addEventListener('DOMContentLoaded', function(){
    try { newCaptcha(); } catch(e){}
  });
  window.addEventListener('hashchange', function(){ try { newCaptcha(); } catch(e){} });
})();

<script>
(function(){
  // Math captcha
  let _a=0,_b=0; function rnd(){return Math.floor(Math.random()*10)}
  window.regenCaptcha = window.regenCaptcha || function(){
    _a=rnd(); _b=rnd();
    var A=document.getElementById('capA'); if(A) A.textContent=_a;
    var B=document.getElementById('capB'); if(B) B.textContent=_b;
    var I=document.getElementById('capAns'); if(I) I.value='';
  };
  document.addEventListener('DOMContentLoaded', regenCaptcha);

  // Core actions
 
  async function _claim(){
    var acctEl=document.getElementById('acct');
    var acct=acctEl?acctEl.textContent:'';
    if(!acct || acct==='Not connected'){ alert('Connect wallet first.'); return; }
    var I=document.getElementById('capAns'); var v=parseInt(I?I.value:'',25);
    if(isNaN(v)||v!==(_a+_b)){ alert('Wrong answer, try again.'); regenCaptcha(); return; }
    try{
      const r=await fetch((CONFIG && CONFIG.USE_CORS_PROXY ? (CONFIG.CORS_PROXY + 'https://cfc-faucet.onrender.com/api/faucet') : 'https://cfc-faucet.onrender.com/api/faucet'),{
        method:'POST',headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ address: acct, amount: 25, currency: 'CFC' })
      });
      if(!r.ok) throw new Error('Faucet error');
      alert('âœ… 25 CFC sent!');
      regenCaptcha();
    }catch(e){ console.error(e); alert('Faucet request failed'); }
  }

  // Provide both names
  window.connectWallet = window.connectWallet || _connect;
  window.onConnect    = window.onConnect    || _connect;
  window.handleClaim  = window.handleClaim  || _claim;
  window.onClaim      = window.onClaim      || _claim;

  // Force-bind by ID
  function tryBind(id, fn){
    var el=document.getElementById(id);
    if (el && !el.onclick) el.onclick = fn;
  }
  tryBind('connectBtn', _connect);
  tryBind('claimBtn', _claim);

  // Fallback: bind by button text if IDs differ
  function bindByText(txt, fn){
    var btns=[...document.querySelectorAll('button')];
    btns.forEach(b=>{
      var t=(b.textContent||'').toLowerCase();
      if (t.includes(txt) && !b.onclick){ b.onclick = fn; }
    });
  }
  bindByText('connect xaman', _connect);
  bindByText('connect wallet', _connect);
  bindByText('claim', _claim);
})();
</script>
<script>
(function(){
  function alias(from, to){
    try{
      if (typeof window[from]==='function' && typeof window[to] !== 'function'){ window[to]=window[from]; }
      else if (typeof window[to]==='function' && typeof window[from] !== 'function'){ window[from]=window[to]; }
    }catch(e){}
  }
  document.addEventListener('DOMContentLoaded', function(){
    alias('onConnect','connectWallet');
    alias('onClaim','handleClaim');
    var cb=document.getElementById('connectBtn'); if(cb && !cb.onclick) cb.onclick = (window.connectWallet||window.onConnect);
    var cl=document.getElementById('claimBtn');   if(cl && !cl.onclick) cl.onclick   = (window.handleClaim||window.onClaim);
  });
})();
</script>
<script>
    // Unified pay functions (server redirect via your Render backend)
    function payRLUSD(){ window.open('https://cfc-faucet.onrender.com/api/pay-rlusd','_blank'); }
    function payXRP(){ window.open('https://cfc-faucet.onrender.com/api/pay-xrp','_blank'); }
    function payItemRLUSD(label){ window.open('https://cfc-faucet.onrender.com/api/pay-rlusd','_blank'); }
    function payItemXRP(label){ window.open('https://cfc-faucet.onrender.com/api/pay-xrp','_blank'); }
  </script>
<script>
    (function(){
      function bind(id, fn){
        var el = document.getElementById(id);
        if (el && !el.__bound){ el.__bound = true; el.addEventListener('click', function(ev){ ev.preventDefault(); fn(); }); }
      }
      function bindAll(){
        bind('buy1rlusd', function(){ payItemRLUSD('service'); });
        bind('buy1xrp', function(){ payItemXRP('service'); });
        bind('buy2rlusd', function(){ payItemRLUSD('workshop'); });
        bind('buy2xrp', function(){ payItemXRP('workshop'); });
        bind('buy3rlusd', function(){ payItemRLUSD('book'); });
        bind('buy3xrp', function(){ payItemXRP('book'); });
      }
     // ---- begin safe init (keeps wallet + claim working, no regressions) ----
// Run wallet/core init immediately if your site defines it.
if (typeof boot === 'function') {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', boot);
  } else {
    boot();
  }
}
// Delay ONLY the payment button wiring to help Chrome finish loading SDKs.
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => setTimeout(bindAll, 500));
} else {
  setTimeout(bindAll, 500);
}
try {
  new MutationObserver(() => setTimeout(bindAll, 500))
    .observe(document.documentElement, { childList: true, subtree: true });
} catch(e) {}
})();
// ---- end safe init ----
  </script>
<script>
    (function(){
      const form = document.getElementById('joinForm');
      if (!form) return;
      const emailEl = document.getElementById('joinEmail');
      const statusEl = document.getElementById('joinStatus');
      form.addEventListener('submit', async function(ev){
        ev.preventDefault();
        const email = (emailEl.value || '').trim();
        if(!email){ return; }
        statusEl.className='status warn'; statusEl.textContent='Submittingâ€¦';
        try{
          const res = await fetch((CONFIG && CONFIG.USE_CORS_PROXY ? (CONFIG.CORS_PROXY + 'https://cfc-faucet.onrender.com/api/join') : 'https://cfc-faucet.onrender.com/api/join'), {
            method:'POST', headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ email })
          });
          const j = await res.json();
          if (j && j.ok){
            statusEl.className='status ok'; statusEl.textContent='ðŸŽ‰ Youâ€™re in!';
            emailEl.value='';
          } else {
            statusEl.className='status err'; statusEl.textContent=(j && j.error) || 'Join failed';
          }
        }catch(e){
          statusEl.className='status err'; statusEl.textContent='Network error';
        }
      });
    })();
  </script>

<script>
(function(){
  function gid(id){ return document.getElementById(id); }
  
  CONFIG.FAUCET_ENDPOINT = CONFIG.FAUCET_ENDPOINT || 'https://cfc-faucet.onrender.com/api/faucet';
  CONFIG.JOIN_ENDPOINT   = CONFIG.JOIN_ENDPOINT   || 'https://cfc-faucet.onrender.com/api/join';
  CONFIG.PAY_CFC_URL     = CONFIG.PAY_CFC_URL     || 'https://cfc-faucet.onrender.com/api/pay-cfc';
  CONFIG.PAY_XRP_URL     = CONFIG.PAY_XRP_URL     || 'https://cfc-faucet.onrender.com/api/pay-xrp';
  CONFIG.CFC_CURRENCY    = CONFIG.CFC_CURRENCY    || 'CFC';
  CONFIG.CFC_ISSUER      = CONFIG.CFC_ISSUER      || '';
  CONFIG.XRPL_WSS        = CONFIG.XRPL_WSS        || 'wss://xrplcluster.com';

  let account = localStorage.getItem('xrpl_account') || '';
  let connected = false;

  const bar = gid('walletbar'), st = gid('wb_status'), wa = gid('wb_account'), wx = gid('wb_xrp'), wc = gid('wb_cfc'), wtrust = gid('wb_trust');
  function showBar(){ if(bar) bar.style.display='flex'; }
  function setStatus(t){ if(st){ st.textContent=t; } }
  function setAccount(a){ if(wa){ wa.textContent = a||'â€”'; } }
  function setXrp(v){ if(wx){ wx.textContent = v; } }
  function setCfc(v){ if(wc){ wc.textContent = v; } }

  async function connectXRPLAndLoadBalances(acct){
    try{
      if(!window.xrpl){ console.warn('XRPL SDK not ready'); return; }
      const client = new xrpl.Client(CONFIG.XRPL_WSS);
      await client.connect();
      try{
        const ai = await client.request({ command:'account_info', account: acct, ledger_index:'validated' });
        const xrp = (ai.result.account_data.Balance/1000000).toFixed(6);
        setXrp(xrp);
      }catch(e){ setXrp('â€”'); }
      if(CONFIG.CFC_ISSUER){
        try{
          const al = await client.request({ command:'account_lines', account: acct, ledger_index:'validated', peer: CONFIG.CFC_ISSUER });
          let cfc = '0';
          (al.result.lines||[]).forEach(line=>{
            if(line.currency===CONFIG.CFC_CURRENCY){ cfc = line.balance; }
          });
          setCfc(cfc);
          const hasLine = (al.result.lines||[]).some(l => l.currency===CONFIG.CFC_CURRENCY);
          if(wtrust) wtrust.style.display = hasLine ? 'none' : 'inline-block';
        }catch(e){
          setCfc('â€”');
          if(wtrust) wtrust.style.display = 'inline-block';
        }
      }else{
        setCfc('â€”');
      }
      client.disconnect();
    }catch(e){ console.warn(e); }
  }

  

  const connectBtn = gid('connectBtn');
  if(connectBtn && !connectBtn.__wired){
    connectBtn.__wired = true;
    connectBtn.addEventListener('click', doConnect);
  }
  if(account){
    showBar(); setStatus('Connected'); setAccount(account);
    try{var _b=document.getElementById('connectBtn'); if(_b){ _b.textContent='Connected'; _b.disabled=false; }}catch(e){} connectXRPLAndLoadBalances(account);
  }

  const claimBtn = gid('claimBtn');
  const claimStatus = gid('claimStatus');
  const claimSpin = gid('claimSpin');
  const capQ = gid('capQ'), capA = gid('capA'), capRefresh = gid('capRefresh');
  let a=0,b=0;
  function regen(){
    if(!capQ) return;
    a = Math.floor(Math.random()*10); b = Math.floor(Math.random()*10);
    capQ.textContent = 'Solve: ' + a + ' + ' + b + ' = ?';
    if(capA) capA.value='';
  }
  if(capRefresh) capRefresh.addEventListener('click', regen);
  if(document.readyState!=='loading') regen(); else document.addEventListener('DOMContentLoaded', regen);

  async function postJson(url, data){
    const r = await fetch(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(data||{}) });
    return r.json();
  }

  if(claimBtn && !claimBtn.__wired){
    claimBtn.__wired = true;
    claimBtn.addEventListener('click', async function(){
      if(capQ && capA){
        const ans = parseInt(capA.value||'NaN',10);
        if(isNaN(ans) || ans !== (a+b)){
          if(claimStatus){ claimStatus.className='status err'; claimStatus.textContent='Wrong math answer'; }
          return;
        }
      }
      if(!account){
        alert('Connect Xaman first so we know your account.');
        return;
      }
      if(claimStatus){ claimStatus.className='status warn'; claimStatus.textContent='Sendingâ€¦'; }
      if(claimSpin){ claimSpin.style.display='inline-block'; }
      try{
        const j = await postJson(CONFIG.FAUCET_ENDPOINT, { captcha_ok:true, account });
        if(j && j.ok){
          if(claimStatus){ claimStatus.className='status ok'; claimStatus.textContent='âœ… 25 CFC sent (pending ledger)â€¦'; }
          setTimeout(()=>connectXRPLAndLoadBalances(account), 8000);
        }else{
          if (claimStatus){ 
  claimStatus.className='status err'; 
  claimStatus.textContent=''; 
}
        }
      }catch(e){
        if(claimStatus){ claimStatus.className='status err'; claimStatus.textContent='Network error'; }
      }finally{
        if(claimSpin){ claimSpin.style.display='none'; }
      }
    });
  }

  const joinEmail = gid('joinEmail') || gid('emailInput');
  const joinBtn = gid('joinBtn') || gid('emailSubmit');
  const joinStatus = gid('joinStatus') || gid('emailMsg');
  if(joinBtn && !joinBtn.__wired){
    joinBtn.__wired = true;
    joinBtn.addEventListener('click', async function(){
      const email = (joinEmail && joinEmail.value || '').trim();
      if(!email || !/\\S+@\\S+\\.\\S+/.test(email)){
        if(joinStatus){ joinStatus.className='status err'; joinStatus.textContent='Enter a valid email'; }
        return;
      }
      if(joinStatus){ joinStatus.className='status warn'; joinStatus.textContent='Submittingâ€¦'; }
      try{
        const j = await postJson(CONFIG.JOIN_ENDPOINT, { email });
        if(j && j.ok){
          if(joinStatus){ joinStatus.className='status ok'; joinStatus.textContent='ðŸŽ‰ Youâ€™re in!'; }
          if(joinEmail) joinEmail.value='';
        }else{
          if(joinStatus){ joinStatus.className='status err'; joinStatus.textContent=(j&&j.error)||'Join failed'; }
        }
      }catch(e){
        if(joinStatus){ joinStatus.className='status err'; joinStatus.textContent='Network error'; }
      }
    });
  }

  
  if(wtrust && !wtrust.__wired){
    wtrust.__wired = true;
    wtrust.addEventListener('click', async function(){
      try{
        if(!window.xumm){ alert('Xaman SDK not ready'); return; }
        if(!CONFIG.CFC_ISSUER){ alert('Missing CONFIG.CFC_ISSUER'); return; }
        const payload = {
          "TransactionType": "TrustSet",
          "LimitAmount": {
            "currency": CONFIG.CFC_CURRENCY,
            "issuer": CONFIG.CFC_ISSUER,
            "value": "1000000000"
          }
        };
        const res = await xumm.payload.create(payload);
        if(res?.next?.always){
          window.open(res.next.always, "_blank");
        } else {
          alert('Could not create trustline payload');
        }
      }catch(e){
        console.error(e);
        alert('Trustline failed');
      }
    });
  }
})();
</script>
<script>
(function(){
  // augment config safely
  window.CONFIG = Object.assign(window.CONFIG||{}, {
    JOIN_ENDPOINT: 'https://cfc-faucet.onrender.com/api/join',
    PAY_CFC_URL: 'https://cfc-faucet.onrender.com/api/pay-cfc',
    PAY_XRP_URL: 'https://cfc-faucet.onrender.com/api/pay-xrp',
    XRPL_WS: 'wss://xrplcluster.com',
    XUMM_APP_UUID: 'e130c57f-bd16-4458-bee3-de32826dd900'
  });
  var CFG = window.CONFIG;

  // Xumm loader (avoid duplicates)
  if(!window.xumm && typeof Xumm!=='undefined'){
    try{ window.xumm = new Xumm(CFG.XUMM_APP_UUID); console.log('Constructed Xumm Object'); }catch(e){}
  }

  function byId(id){ return document.getElementById(id); }

  // Connect handler
  var connectedAccount = null;
  function connectXaman(){
    try{
      if(!window.Xumm){ console.warn('Xumm SDK not loaded'); return; }
      var x = new Xumm(CFG.XUMM_APP_UUID);
      x.signIn().then(function(s){
        if (s && s.me && s.me.account){
          connectedAccount = s.me.account;
          var cs = byId('connStatus'); if(cs) cs.textContent='Connected';
          var ac = byId('acct'); if(ac) ac.textContent=connectedAccount;
          refreshBalances();
        }
      });
    }catch(e){ console.error(e); }
  }
  var btn = document.getElementById('connectBtn');
  if(btn){ btn.addEventListener('click', connectXaman); }

  // XRPL read balances
  var xrplClient = null;
  async function getClient(){
    if (xrplClient && xrplClient.isConnected()) return xrplClient;
    xrplClient = new xrpl.Client(CFG.XRPL_WS);
    await xrplClient.connect();
    return xrplClient;
  }
  async function refreshBalances(){
    if(!connectedAccount) return;
    try {
      var c = await getClient();
      try{
        var ai = await c.request({ command:'account_info', account:connectedAccount, ledger_index:'validated' });
        var xrp = (ai.result && ai.result.account_data && ai.result.account_data.Balance) ? (ai.result.account_data.Balance/1e6).toFixed(6) : 'â€”';
        var el = byId('xrpBal'); if(el) el.textContent = xrp;
      }catch(e){}
      try{
        var al = await c.request({ command:'account_lines', account:connectedAccount, ledger_index:'validated' });
        var line = ((al.result && al.result.lines) || []).find(function(l){ return l.currency==='CFC'; });
        var cfc = line ? line.balance : 'â€”';
        var el2 = byId('cfcBal'); if(el2) el2.textContent = cfc;
      }catch(e){}
    }catch(e){ console.warn(e); }
  }

  // Hook faucet Claim button to pass account
  var claimBtn = document.getElementById('claimBtn');
  if(claimBtn){
    claimBtn.addEventListener('click', function(){
      // If page has existing handler, we don't override; we look for a known status element to update after
      // Instead, we intercept fetch by exposing CONFIG.FAUCET_ENDPOINT and expecting app code to read CONFIG
      // No-op here.
    });
  }

  // Patch Claim to include account if site uses a global sendClaim function
  if (typeof window.sendClaim==='function'){
    var orig = window.sendClaim;
    window.sendClaim = function(){
      try{
        if (connectedAccount) window.__connectedAccount = connectedAccount;
      }catch(e){}
      return orig.apply(this, arguments);
    }
  }
})();
</script>
<script>
(function(){
  // Globals
  const connectBtn = document.getElementById('connectBtn');
  const cfcBalEl = document.getElementById('cfcBal');
  const xrpBalEl = document.getElementById('xrpBal');
  const addrBadge = document.getElementById('addrBadge');

  let connectedAccount = null;

  async function fetchBalances(address){
    try{
      if(!window.xrpl) return;
      const client = new xrpl.Client("wss://s1.ripple.com");
      await client.connect();
      // XRP balance
      const acct = await client.request({ command: "account_info", account: address, ledger_index: "validated" });
      const xrpDrops = acct.result.account_data.Balance || "0";
      const xrp = (parseInt(xrpDrops,10)/1000000).toFixed(6);
      if(xrpBalEl) xrpBalEl.textContent = xrp;

      // CFC balance (trustline) currency = CFC, any issuer (or specific if provided via CONFIG)
      const lines = await client.request({ command: "account_lines", account: address, ledger_index: "validated" });
      const cfcLine = (lines.result.lines || []).find(l => (l.currency === (window.CONFIG && window.CONFIG.currencyCode ? window.CONFIG.currencyCode : "CFC")));
      if(cfcBalEl) cfcBalEl.textContent = cfcLine ? cfcLine.balance : "0";
      await client.disconnect();
    }catch(e){
      console.error("balance fetch error", e);
    }
  }

    }catch(e){
      console.error(e);
      toast && toast("Xaman connect failed");
    }
  }

  if(connectBtn){
    connectBtn.addEventListener('click', function(){

  if(connectedAccount){ return; }
  connectXumm();
});
  }

  // Provide a global for other handlers (Claim) to know connection
  window.__cfcConnectedAccount = () => connectedAccount;

  // CLAIM handler: reuse existing connection, do not force second sign-in
  const claimBtn = document.getElementById('claimBtn');
  if(claimBtn){
    claimBtn.addEventListener('click', async function(){
      try{
        const acct = connectedAccount;
        if(!acct){
          // if not connected yet, try to connect once
          await connectXumm();
        }
        const address = connectedAccount;
        if(!address){
          toast && toast("Please connect Xaman first.");
          return;
        }
        // Post to faucet endpoint
        const payload = { account: address, captcha_ok: true };
        const ep = (window.CONFIG && window.CONFIG.FAUCET_ENDPOINT) ? window.CONFIG.FAUCET_ENDPOINT : "%FAUCET_ENDPOINT%";
        const r = await fetch(ep, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(payload) });
        const j = await r.json().catch(()=>({}));
        if(r.ok){
          toast && toast("Claim successful");
          fetchBalances(address);
        }else{
          toast && toast(j && (j.error || j.message) ? String(j.error || j.message) : "Claim failed");
        }
      }catch(err){
        console.error(err);
        toast && toast("Claim error");
      }
    });
  }

  // Try to auto-connect silently if session exists
  if(window.xumm){
    try{
      window.xumm.on("ready", ()=>{
        // no-op; explicit connect on click
      });
    }catch(e){}
  }
})();
</script>
<!-- CFC-AUTO-SCRIPT -->
<script>
(function(){
  const connectBtn = document.getElementById('connectBtn');
  const addrBadge  = document.getElementById('addrBadge');
  const xrpBalEl   = document.getElementById('xrpBal');
  const cfcBalEl   = document.getElementById('cfcBal');
  const claimBtn   = document.getElementById('claimBtn');
  const CONFIG     = window.CONFIG || {};
  let connectedAccount = null;

  function isValidR(r){ return typeof r === 'string' && /^r[1-9A-HJ-NP-Za-km-z]{25,}$/i.test(r); }
  function setConnected(addr){
    if(!isValidR(addr)) return;
    connectedAccount = addr;
    try { sessionStorage.setItem("cfc_addr", addr); } catch(e){}
    if(connectBtn){ connectBtn.textContent = "Connected"; connectBtn.disabled = false; }
    if(addrBadge){ addrBadge.textContent = addr; }
    fetchBalances(addr);
  }

  async function fetchBalances(address){
    try{
      if(!window.xrpl) return;
      const client = new xrpl.Client("wss://s1.ripple.com");
      await client.connect();
      const info = await client.request({ command:"account_info", account: address, ledger_index:"validated" });
      const xrp = (parseInt(info.result.account_data.Balance||"0",10)/1e6).toFixed(6);
      if(xrpBalEl) xrpBalEl.textContent = xrp;
      const code = (CONFIG.currencyCode || "CFC");
      const issuer = (CONFIG.issuer || "rsxUkmjnAn8PRDz8RYrPusb9mTDYn5NqG8");
      const lines = await client.request({ command:"account_lines", account: address, ledger_index:"validated", peer: issuer });
      const line = (lines.result.lines||[]).find(l => l.currency === code);
      if(cfcBalEl) cfcBalEl.textContent = line ? line.balance : "0";
      await client.disconnect();
    }catch(e){ console.error("balance fetch error", e); }
  }

  if(connectBtn){
    connectBtn.addEventListener('click', function(){ if(!connectedAccount) connectXumm(); });
  }

  try{ const prev = sessionStorage.getItem("cfc_addr"); if(isValidR(prev)) setConnected(prev); }catch(e){}

  if(window.xumm && window.xumm.on){
    try{
      window.xumm.on("ready", () => {
        try{ if(window.xumm.user && window.xumm.user.account) setConnected(window.xumm.user.account); }catch(e){}
      });
      window.xumm.on("success", (e) => {
        const acc = (e && e.me && e.me.account) ? e.me.account : (e && e.account ? e.account : null);
        if(acc) setConnected(acc);
      });
      window.xumm.on("retrieved", (e) => {
        const acc = (e && e.me && e.me.account) ? e.me.account : (e && e.account ? e.account : null);
        if(acc) setConnected(acc);
      });
    }catch(e){}
  }

  if(claimBtn){
    claimBtn.addEventListener('click', async function(){
      try{
        if(!isValidR(connectedAccount)){ await connectXumm(); }
        if(!isValidR(connectedAccount)){ return; }
        const payload = { account: connectedAccount, captcha_ok: true };
        const ep = CONFIG.FAUCET_ENDPOINT || "https://cfc-faucet.onrender.com/api/faucet";
        const r = await fetch(ep, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(payload) });
        if(r.ok){ fetchBalances(connectedAccount); }
        const txt = await r.text().catch(()=>"" );
        if(!r.ok){ console.error("Claim failed:", txt); }
      }catch(err){ console.error("Claim error", err); }
    });
  }
})();
</script>
</div></div>
<script>
(function() {
  // Configuration
  const API_BASE = (typeof window.CFC_API_BASE !== 'undefined' && window.CFC_API_BASE) || "https://cfc-faucet.onrender.com";
  const XUMM_API_KEY = "e130c57f-bd16-4458-bee3-de32826dd900";

  // DOM refs
  const connectBtn = document.getElementById('connectXaman') || document.querySelector('[data-connect-xaman]');
  const addrSpan = document.getElementById('connectedAddress');
  const xrpSpan = document.getElementById('xrpBalance');
  const cfcSpan = document.getElementById('cfcBalance');
  const claimBtn = document.getElementById('claimButton') || document.querySelector('[data-claim]');
  const captchaInput = document.getElementById('captchaAnswer') || document.querySelector('[data-captcha-answer]');
  const captchaA = document.getElementById('captchaA') || document.querySelector('[data-captcha-a]');
  const captchaB = document.getElementById('captchaB') || document.querySelector('[data-captcha-b]');
  const statusArea = document.getElementById('statusArea') || document.querySelector('[data-status]');

  // Styling guarantee: do not change colors; only set states
  function setStatus(msg) {
    if (statusArea) { statusArea.textContent = msg; }
    console.log(msg);
  }

  // XUMM SDK
  let xumm;
  let connectedAccount = null;

  function initXumm() {
    try {
      // The SDK is served from /sdk/xumm.min.js on the backend domain; ensure it's loaded
      if (typeof Xumm === 'undefined') {
        console.warn('Xumm SDK not found on window. Make sure /sdk/xumm.min.js is included.');
        return;
      }
      xumm = new Xumm(XUMM_API_KEY);
      // Restore session if any
      xumm.on('ready', () => {
        setStatus('Xaman SDK ready');
      });
      xumm.on('success', () => {
        // Authorization success
        if (xumm?.user?.account) {
          applyConnected(xumm.user.account);
        }
      });
      xumm.on('retrieved', () => {
        if (xumm?.user?.account) {
          applyConnected(xumm.user.account);
        }
      });
    } catch (e) {
      console.error('Xumm init error:', e);
    }
  }

  function truncate(addr) {
    if (!addr) return '';
    return addr.slice(0, 6) + '...' + addr.slice(-6);
  }

  async function refreshBalances(address) {
    try {
      if (!address) return;
      const res = await fetch(API_BASE + '/api/balances?account=' + encodeURIComponent(address));
      if (!res.ok) throw new Error('Balances fetch failed');
      const data = await res.json();
      if (typeof data.xrp !== 'undefined' && xrpSpan) xrpSpan.textContent = data.xrp;
      if (typeof data.cfc !== 'undefined' && cfcSpan) cfcSpan.textContent = data.cfc;
    } catch (e) {
      console.warn('Balance update failed', e);
    }
  }

  function applyConnected(address) {
    connectedAccount = address;
    if (addrSpan) addrSpan.textContent = address || 'Not connected';
    // Also show a short form if there's an element for it
    const shortAddrEl = document.getElementById('connectedAddressShort');
    if (shortAddrEl) shortAddrEl.textContent = truncate(address);
    // Enable claim now that we have an account
    if (claimBtn) claimBtn.removeAttribute('disabled');
    refreshBalances(address);
  }


  function generateCaptchaIfNeeded() {
    if (!captchaA || !captchaB || !captchaInput) return;
    // Assume the numbers are already rendered by backend/page; if not, set defaults
    const a = parseInt(captchaA.textContent || captchaA.value || '0', 10);
    const b = parseInt(captchaB.textContent || captchaB.value || '0', 10);
    if (Number.isNaN(a) || Number.isNaN(b)) {
      // Generate simple fallback numbers
      const aa = Math.floor(1 + Math.random() * 9);
      const bb = Math.floor(1 + Math.random() * 9);
      captchaA.textContent = String(aa);
      captchaB.textContent = String(bb);
    }
  }

  async function handleClaim() {
    try {
      if (!connectedAccount || connectedAccount === 'undefined' || connectedAccount === null) {
        setStatus('Please connect your wallet first.');
        if (connectBtn) connectBtn.focus();
        return;
      }
      // Validate captcha
      if (!captchaA || !captchaB || !captchaInput) {
        setStatus('Captcha not found.');
        return;
      }
      const a = parseInt(captchaA.textContent || captchaA.value || '0', 10);
      const b = parseInt(captchaB.textContent || captchaB.value || '0', 10);
      const ans = parseInt(captchaInput.value || '0', 10);
      if (ans !== (a + b)) {
        setStatus('Captcha incorrect. Please try again.');
        captchaInput.focus();
        return;
      }
      setStatus('Requesting faucet...');
      const res = await fetch(API_BASE + '/api/faucet', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ account: connectedAccount, captcha_ok: true })
      });
      if (!res.ok) {
        const t = await res.text();
        throw new Error(t || 'Faucet failed');
      }
      const data = await res.json().catch(()=>({}));
      setStatus('Faucet sent: 25 CFC. Check your wallet.');
      // Refresh balances after a short delay
      setTimeout(() => refreshBalances(connectedAccount), 1500);
    } catch (e) {
      console.error(e);
      setStatus('Faucet error: ' + (e.message || 'Unknown error'));
    }
  }

  // Bind events
  document.addEventListener('DOMContentLoaded', () => {
    initXumm();
    generateCaptchaIfNeeded();
    if (connectBtn) connectBtn.addEventListener('click', handleConnect);
    if (claimBtn) claimBtn.addEventListener('click', handleClaim);
    // Disable claim until connected
    if (claimBtn) claimBtn.setAttribute('disabled', 'disabled');
  });
})();
</script>
<script>
(() => {
  let connectedAccount = null;

  async function restore() {
    try {
      const saved = localStorage.getItem('xummAccount');
      if (saved) {
        connectedAccount = saved;
        const el = document.getElementById('connectedAddress');
        if (el) el.textContent = saved;
        if (typeof fetchBalances === 'function') {
          await fetchBalances(saved);
        }
      }
    } catch(e) { console.error(e); }
  }

  async function claim() {
    const s = document.getElementById('claimStatus');
    if (!connectedAccount || connectedAccount === 'undefined' || connectedAccount === null) {
      if (s) s.textContent = 'Connect Wallet First';
      return;
    }
    try {
      const resp = await fetch('https://cfc-faucet.onrender.com/api/faucet', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ account: connectedAccount, captcha_ok: true })
      });
      const data = await resp.json();
      if (data.ok) {
        if (s) s.textContent = 'Success! Faucet sent.';
        if (typeof fetchBalances === 'function') await fetchBalances(connectedAccount);
      } else {
        if (s) s.textContent = data.error || 'Faucet failed.';
      }
    } catch (e) {
      if (s) s.textContent = 'Network error.';
    }
  }

  window.addEventListener('load', restore);
  const btn = document.getElementById('connectBtn');
  if (btn) btn.addEventListener('click', connectNow);
  const cbtn = document.getElementById('claimBtn');
  if (cbtn) cbtn.addEventListener('click', (e)=>{ e.preventDefault(); claim(); });
})();
</script>
<!-- Injected: targeted fixes overlay -->
<script>
(function(){
  function gid(id){ return document.getElementById(id); }
  function $all(sel){ return Array.from(document.querySelectorAll(sel)); }
  function acct(){
    if (typeof window.connectedAccount === 'string' && window.connectedAccount) return window.connectedAccount;
    try{ const s = localStorage.getItem('xummAccount'); if (s) return s; }catch(e){}
    return "";
  }
  function isR(a){ return typeof a==='string' && /^r[1-9A-HJ-NP-Za-km-z]{25,34}$/.test(a); }

  function updateWallet(){
    var a = acct();
    var targets = [gid('wallet-address'), gid('connectedAddress'), gid('addrBadge'), gid('walletbar')].filter(Boolean);
    targets.forEach(function(el){
      try{ el.innerHTML = el.innerHTML.replace('[object Promise]','').replace(/XRP:\s*â€”?/gi,'').replace(/CFC:\s*â€”?/gi,''); }catch(e){}
      el.textContent = (isR(a) ? 'Connected Account: ' + a : 'Wallet Status: CONNECT');
    });
    var btn = gid('connect-wallet') || gid('connectXumm') || gid('xummConnect') || gid('connectBtn');
    if (btn) btn.textContent = isR(a) ? 'Disconnect XUMM Wallet' : 'Connect XUMM Wallet';
  }

  function connectToggle(){
    var btn = gid('connect-wallet') || gid('connectXumm') || gid('xummConnect') || gid('connectBtn');
    if (!btn) return;
    var clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);
    clone.addEventListener('click', async function(e){
      e.preventDefault();
      var a = acct();
      if (isR(a)){
        try{ localStorage.removeItem('xummAccount'); }catch(e){}
        if (typeof window.connectedAccount !== 'undefined') window.connectedAccount = null;
        updateWallet();
        return;
      }
      try{
        if (window.xumm && typeof window.xumm.authorize === 'function'){
          // Enhanced full disconnect before returning
          try{
            if (window.xumm && typeof window.xumm.logout === 'function') {
              await window.xumm.logout();
            }
          }catch(_){}
          try{

  // Suppress redundant "connect wallet" alerts if already connected
  (function(){
    var nat = window.alert;
    window.alert = function(msg){
      if (isR(acct()) && typeof msg === 'string' && /connect wallet/i.test(msg)) return;
      return nat.apply(window, arguments);
    };
  })();

  // Auto-clear success message after 5s
  (function(){
    var nodes = [gid('faucet-result'), gid('claimStatus')].filter(Boolean);
    nodes.forEach(function(node){
      var obs = new MutationObserver(function(){
        var txt = (node.textContent || '').toLowerCase();
        if (txt.includes('success') && txt.includes('faucet')){
          setTimeout(function(){ node.textContent=''; }, 5000);
        }
      });
      obs.observe(node, { childList:true, subtree:true, characterData:true });
    });
  })();

  function init(){
    updateWallet();
    connectToggle();
    cleanTexts();
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
  setTimeout(updateWallet, 1000);
  setInterval(updateWallet, 4000);
})();
</script>
</body>
<script>
(function(){
  // local helpers (no globals)
  var $ = function(sel, root){ return (root||document).querySelector(sel); };

  // Discover elements actually present in your page
  var claimBtn = document.getElementById('claimBtn') || document.querySelector('#faucet button.btn');
  var claimStatus = document.getElementById('claimStatus') || document.querySelector('#faucet .status');
  var claimSpin = document.getElementById('claimSpin');
  var capQ = document.getElementById('capQ');
  var capA = document.getElementById('capA');
  var capRefresh = document.getElementById('capRefresh');

  var joinForm = document.getElementById('joinForm');
  var joinEmail = document.getElementById('joinEmail') || document.getElementById('emailInput');
  var joinBtn = document.getElementById('joinBtn') || document.getElementById('emailSubmit');
  var joinStatus = document.getElementById('joinStatus') || document.getElementById('emailMsg');

  // Endpoints (use existing if already in your page's CONFIG)
  var FAUCET_ENDPOINT = (window.CONFIG && window.CONFIG.FAUCET_ENDPOINT) || 'https://cfc-faucet.onrender.com/api/faucet';

  // Captcha (only if those elements exist)
  var a=0,b=0;
  function regen(){
    if (!capQ) return;
    a = Math.floor(Math.random()*10);
    b = Math.floor(Math.random()*10);
    capQ.textContent = 'Solve: ' + a + ' + ' + b + ' = ?';
    if (capA) capA.value = '';
  }
  if (capRefresh) capRefresh.addEventListener('click', regen);
  if (capQ) { if (document.readyState !== 'loading') regen(); else document.addEventListener('DOMContentLoaded', regen); }

  async function postJson(url, data){
    const r = await fetch(url, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(data||{})
    });
    return r.json();
  }

  // Wire CLAIM if a button exists and not already wired
  if (claimBtn && !claimBtn.__wired){
    claimBtn.__wired = true;
    claimBtn.addEventListener('click', async function(){
      if (capQ && capA){
        var ans = parseInt(capA.value||'NaN',10);
        if (isNaN(ans) || ans !== (a+b)){
          if (claimStatus){ claimStatus.className='status err'; claimStatus.textContent='Wrong math answer'; }
          return;
        }
      }
      if (claimStatus){ claimStatus.className='status warn'; claimStatus.textContent='Sendingâ€¦'; }
      if (claimSpin){ claimSpin.style.display='inline-block'; }
      try{
        const j = await postJson(FAUCET_ENDPOINT, { captcha_ok:true });
        if (j && j.ok){
          if (claimStatus){ claimStatus.className='status ok'; claimStatus.textContent='âœ… 10 CFC sent!'; }
          regen();
        }else{
          if (claimStatus){ 
  claimStatus.className='status err'; 
  claimStatus.textContent=''; 
}

        }
      }catch(e){
        if (claimStatus){ claimStatus.className='status err'; claimStatus.textContent='Network error'; }
      }finally{
        if (claimSpin){ claimSpin.style.display='none'; }
      }
    });
  }

  // Wire JOIN
  var joinHandlerTarget = joinBtn || (joinForm && joinForm);
  if (joinHandlerTarget && !joinHandlerTarget.__wired){
    joinHandlerTarget.__wired = true;
    var handler = async function(ev){
      if (ev && ev.preventDefault) ev.preventDefault();
      var email = (joinEmail && joinEmail.value || '').trim();
      if (!email || !/\S+@\S+\.\S+/.test(email)){
        if (joinStatus){ joinStatus.className='status err'; joinStatus.textContent='Enter a valid email'; }
        return false;
      }
      if (joinStatus){ joinStatus.className='status warn'; joinStatus.textContent='Submittingâ€¦'; }
      try{
        const j = await postJson(JOIN_ENDPOINT, { email });
        if (j && j.ok){
          if (joinStatus){ joinStatus.className='status ok'; joinStatus.textContent='ðŸŽ‰ Youâ€™re in!'; }
          if (joinEmail) joinEmail.value='';
        } else {
          if (joinStatus){ joinStatus.className='status err'; joinStatus.textContent=(j&&j.error)||'Join failed'; }
        }
      }catch(e){
        if (joinStatus){ joinStatus.className='status err'; joinStatus.textContent='Network error'; }
      }
      return false;
    };
    if (joinBtn) joinBtn.addEventListener('click', handler);
    if (joinForm) joinForm.addEventListener('submit', handler);
  }
})();
</script>
</html>
<!-- âœ… Helper: Hide unwanted text -->
<script>
function cleanTexts(){
  document.querySelectorAll('body *').forEach(function(n){
    var t = (n.innerText || n.textContent || '').trim();
    if (/invalid account/i.test(t) || /^server:\s*waiting for url\.?$/i.test(t)){
      n.style.display = 'none';
    }
  });
}
</script>
<!-- bootstrap: join + claim + divider (non-destructive) -->
<script>
(function(){
  ...

<!-- bootstrap: join + claim + divider (non-destructive) -->
<script>
(function(){
  
  function create(tag, attrs){
    var el = document.createElement(tag);
    if(attrs){ for (var k in attrs){ if(k==='text') el.textContent = attrs[k]; else el.setAttribute(k, attrs[k]); } }
    return el;
  }

  // Add .divider CSS if missing
  function ensureDividerCSS(){
    if ([].some.call(document.styleSheets, s => {
      try { return s.ownerNode && s.ownerNode.textContent && s.ownerNode.textContent.includes('.divider{'); } catch(e){ return false; }
    })) return;
    var style = create('style');
    style.textContent = '.divider{height:1px;background:var(--accent);opacity:0.6;margin:10px 0 14px 0;border-radius:999px}';
    document.head.appendChild(style);
  }

  // Insert divider under CAPTCHA and above Marketplace/My Purchases/Redeem
  function ensureFaucetDivider(){
    var faucet = $('#faucet');
    if (!faucet) return;
    if (faucet.querySelector('.divider')) return;
    var cap = faucet.querySelector('.captcha');
    if (cap){
      var div = create('div'); div.className = 'divider';
      cap.insertAdjacentElement('afterend', div);
      return;
    }
    // fallback: before row containing the 3 buttons
    var rows = faucet.querySelectorAll('.row');
    for (var i=0;i<rows.length;i++){
      var t = rows[i].textContent || '';
      if (/Marketplace|My Purchases|Redeem/i.test(t)){
        var div2 = create('div'); div2.className = 'divider';
        rows[i].insertAdjacentElement('beforebegin', div2);
        break;
      }
    }
  }

  // Ensure claim spinner/status elements after claimBtn
  function ensureClaimUI(){
    var btn = $('#claimBtn');
    if (!btn) return;
    var next = btn.nextElementSibling;
    var hasSpin = !!$('#claimSpin', btn.parentElement || document);
    var hasStatus = !!$('#claimStatus', btn.parentElement || document) || !!document.getElementById('claimStatus');
    if (!hasSpin){
      var spin = create('div', { id:'claimSpin', class:'spinner' });
      spin.style.display = 'none';
      btn.insertAdjacentElement('afterend', spin);
    }
    if (!hasStatus){
      var status = create('div', { id:'claimStatus', class:'status' });
      (btn.parentElement||faucet||document.body).appendChild(status);
    }
  }

  <script>
/* SAFE claim handler: no backend error text is surfaced */
(function(){
  var btn = document.getElementById('claimBtn')
      || document.querySelector('#faucet button.btn');
  if (!btn) return;
  if (btn.__wired) return;
  btn.__wired = true;

  btn.addEventListener('click', async function (ev) {
    ev.preventDefault();
    var status = document.getElementById('claimStatus')
        || document.querySelector('#faucet .status');
    var spin = document.getElementById('claimSpin');

    if (status){ status.className='status warn'; status.textContent='Sendingâ€¦'; }
    if (spin){ spin.style.display='inline-block'; }

    try {
      const url = (window.CONFIG && (CONFIG.FAUCET_ENDPOINT || CONFIG.faucetEndpoint))
                  || 'https://cfc-faucet.onrender.com/api/faucet';
      const r = await fetch(url, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ captcha_ok: true })
      });
      const j = await r.json();

      if (status){
        if (j && j.ok){
          var amt = (window.CONFIG && (CONFIG.faucetAmount || CONFIG.FAUCET_DAILY_AMOUNT)) || 25;
          var code = (window.CONFIG && (CONFIG.currencyCode || CONFIG.CFC_CODE)) || 'CFC';
          status.className='status ok';
          status.textContent='âœ… ' + amt + ' ' + code + ' sent!';
        } else {
          status.className='status err';
          status.textContent='Request failed';
          setTimeout(()=>{ statusEl.textContent=''; statusEl.className='status'; }, 5000);
        }
      }
    
</script>
<script id="cfc-connect-and-bindings">
(function(){
  if(window._cfcPatched) return; window._cfcPatched = true;
  const connectBtn = document.getElementById('connectBtn');
  const claimBtn = document.getElementById('claimBtn');
  const ans = document.getElementById('capAns');
  const addrBadge = document.getElementById('addrBadge') || document.getElementById('address') || document.getElementById('walletAddress');

 
  if(claimBtn){
    claimBtn.onclick = null;
    claimBtn.addEventListener('click', function(e){
      e.preventDefault();
      if(typeof checkCaptcha==='function' ? checkCaptcha() : true){
        if(typeof claimFaucet==='function') claimFaucet();
      }
    });
  }
  if(ans){ ans.addEventListener('input', function(){ if(typeof checkCaptcha==='function') checkCaptcha(); }); }
  if(typeof newCaptcha==='function') newCaptcha();
})();
<script>
document.addEventListener("DOMContentLoaded", () => {
  const savedAccount = localStorage.getItem("connectedAccount");
  if (savedAccount) {
    connectedAccount = savedAccount;
    const connectBtn = document.getElementById("connect-btn");
    const walletAddr = document.getElementById("wallet-address");
    if (connectBtn) connectBtn.textContent = "Connected";
    if (walletAddr) walletAddr.textContent = connectedAccount ? `Connected Wallet: ${connectedAccount}` : '';
    if (typeof updateBalances === 'function') updateBalances(savedAccount);
  }
});
</script>
<!-- This block was showing as text; it MUST live inside <script> -->
<script>
try {
  // (nothing here on purpose: you only had closing parts visible)
} catch (e) {
  if (statusEl){
    statusEl.className='status err';
    statusEl.textContent='Network error';
    setTimeout(()=>{ statusEl.textContent=''; statusEl.className='status'; }, 5000);
  }
} finally {
  if (spin){ spin.style.display='none'; }
}
</script>
<script>
(function(){
  function create(tag, attrs){
    var el = document.createElement(tag);
    if(attrs){ for (var k in attrs){ if(k==='text') el.textContent = attrs[k]; else el.setAttribute(k, attrs[k]); } }
    return el;
  }

  // Ensure Join form exists inside #join
  function ensureJoinForm(){
    var join = document.getElementById('join') || document.querySelector('section#join');
    if (!join) return;
    var form = document.getElementById('joinForm');
    if (!form){
      var container = create('div'); container.style.maxWidth = '420px';
      container.style.marginTop = '10px';
      var f = create('form', { id:'joinForm' }); f.className = 'row'; f.setAttribute('onsubmit','return false;');
      var inp = create('input', { id:'joinEmail', type:'email', placeholder:'you@example.com' });
      var btn = create('button', { id:'joinBtn', type:'submit' }); btn.className = 'btn'; btn.textContent = 'Join';
      f.appendChild(inp); f.appendChild(btn);
      var st = create('div', { id:'joinStatus' }); st.className = 'status';
      container.appendChild(f); container.appendChild(st);
      join.appendChild(container);
    }
  }

  // Wire Join submit (leave endpoint as-is if youâ€™re still using faucet join; otherwise swap URL)
  function wireJoin(){
    var form = document.getElementById('joinForm');
    if (!form || form.__wired) return;
    form.__wired = true;
    form.addEventListener('submit', async function(ev){
      ev.preventDefault();
      var emailEl = document.getElementById('joinEmail');
      var statusEl = document.getElementById('joinStatus');
      var email = (emailEl && emailEl.value || '').trim();
      if(!email){ if(statusEl){ statusEl.className='status err'; statusEl.textContent='Enter an email'; } return; }
      if(statusEl){ statusEl.className='status warn'; statusEl.textContent='Submittingâ€¦'; }
      try{
        const res = await fetch((CONFIG && CONFIG.USE_CORS_PROXY ? (CONFIG.CORS_PROXY + 'https://cfc-faucet.onrender.com/api/join') : 'https://cfc-faucet.onrender.com/api/join'), {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ email })
        });
        const j = await res.json();
        if (statusEl){
          if (j && j.ok){
            statusEl.className='status ok'; statusEl.textContent='ðŸŽ‰ Youâ€™re in!';
            if (emailEl) emailEl.value='';
          } else {
            statusEl.className='status err'; statusEl.textContent=(j && j.error) || 'Join failed';
          }
        }
      }catch(e){
        if(statusEl){ statusEl.className='status err'; statusEl.textContent='Network error'; }
      }
    });
  }

  // Optional helper to hide unwanted text
  function cleanTexts(){
    document.querySelectorAll('body *').forEach(function(n){
      var t = (n.innerText || n.textContent || '').trim();
      if (/invalid account/i.test(t) || /^server:\s*waiting for url\.?$/i.test(t)){
        n.style.display = 'none';
      }
    });
  }

 function boot(){
  try { if (typeof ensureDividerCSS==='function') ensureDividerCSS(); } catch(e){}
  try { if (typeof ensureFaucetDivider==='function') ensureFaucetDivider(); } catch(e){}
  try { if (typeof ensureClaimUI==='function') ensureClaimUI(); } catch(e){}

  // Delay only the claim wiring by 300ms to improve Chrome wallet sync
  setTimeout(() => {
    try { if (typeof wireClaim==='function') wireClaim(); } catch(e){}
  }, 300);
  
  ensureJoinForm();
  wireJoin();
  
  try { cleanTexts(); } catch(e){}
}

  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', boot); }
  else { boot(); }
  try { new MutationObserver(boot).observe(document.documentElement, { childList:true, subtree:true }); } catch(e){}
})();
</script>
<script>
  document.getElementById('emailSubmit').addEventListener('click', async () => {
    const emailInput = document.getElementById('emailInput');
    const emailMsg = document.getElementById('emailMsg');
    const email = emailInput.value.trim();
    
    if (!email) {
      emailMsg.textContent = 'Please enter a valid email.';
      emailMsg.style.color = '#ff6b6b';
      return;
    }
    
    emailMsg.textContent = 'Submitting...';
    emailMsg.style.color = '#9fb0d1';

    try {
      const response = await fetch('https://cfc-faucet.onrender.com/api/join', {  // Updated to Render backend URL
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email })
      });
      const data = await response.json();

      if (data.ok) {
        emailMsg.textContent = 'Thanks for joining the list!';
        emailMsg.style.color = '#1fcf7c';
        emailInput.value = '';switchView('market')

      } else {
        emailMsg.textContent = 'Error: ' + (data.error || 'Please try again');
        emailMsg.style.color = '#ff6b6b';
      }
    } catch (err) {
      console.error(err);
      emailMsg.textContent = 'Submission failed. Try again later.';
      emailMsg.style.color = '#ff6b6b';
    }
  });
</script>
<!-- Auto-height for GoDaddy iframe -->
<script>
function sendHeight() {
    const height = document.body.scrollHeight;
    window.parent.postMessage({ cfcHeight: height }, "*");
}
setInterval(sendHeight, 500);
window.onload = sendHeight;
</script>
<style>
html, body {
  font-size: 18px !important;
}
.btn:not(.small) {
  padding: 14px 20px !important;
  font-size: 18px !important;
}
.btn.small {
  padding: 8px 10px !important;
  font-size: 14px !important;
}
h1 {
  font-size: 32px !important;
}
h3 {
  font-size: 22px !important;
}
</style>
<style>
#dailyFaucetTitle {
  font-size: 26px !important;
}
</style>
<script>
document.addEventListener("DOMContentLoaded", function(){
  const btn = document.getElementById("connectBtn");
  if (!btn) return;

  const xumm = new Xumm("eebd4c17-c3ef-435b-b891-89afb99e259e");

  btn.addEventListener("click", async function(){
    try{
      const sub = await xumm.payload.createAndSubscribe({
        txjson: { TransactionType: "SignIn" },
        options: {
          return_url: {
            web: "https://centerforcreators.com/nft-marketplace",
            app: "https://centerforcreators.com/nft-marketplace"
          }
        }
      }, function(){});

      if (sub?.created?.next?.always) {
        window.location.href = sub.created.next.always;
      }

    } catch(e){
      console.error(e);
    }
  });
});
</script>

</body> 
</html>
